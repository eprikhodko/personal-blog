---
title: "JavaScript foundation, v1.0"
date: "2021-01-21"
hero_image: "./Unofficial_JavaScript_logo_2.png"
hero_image_alt: ""
---

В этом конспекте я попытаюсь разобраться в основах JavaScript.

Сначала буду отвечать на такие вопросы, как:

- что происходит, когда когда браузер читает код, который мы написали в VSCode, как браузер читает этот файл?
- как выполняется JavaScript?
- как работает Node.js?

Если кто то спросит меня, "слушай, а можешь объяснить, как работает JavaScript, как пятилетнему ребенку?", к концу этого конспекта, я должен суметь ответить на этот вопросы, и на многие другие. Объяснить все простыми словами, так, как я это сам понимаю.

## Part 1: JavaScript Engine (Движок JavaScript)

Как мы обычно пишем код? Мы открываем наш любимый редактор и пишем код:

```js file=/some-javascript-file.js
const isLearning = true
```

Нам тут все понятно, мы объявили константу isLearning, и присвоили ей значение true.
Но как сам компьютер понимает, что мы тут написали?

Компьютер понимает только единицы и нули, поэтому если мы дадим ему наш .js файл, он посмотрит на него, и не поймет ровным счетом ничего.
Он не понимает в принципе, что такое JavaScript. Компьютер понимает только 1 и 0, это его родной язык.

Каким тогда образом мы можем объяснить компьютеру, а что это вообще такое, этот JavaScript?

**Для этого нам нужен JavaScript Engine, или JavaScript движок.**

![двигатель V8](./v8-engine.jpg "вот он наш родимый, JavaScript движок")

![диаграмма, показывающая, как JavaScript engine вписывается между компьютером и файлом с javascript кодом](./javascript-engine-diagram.jpg "вот как JavaScript engine вписывается между компьютером и файлом с javascript кодом")

С помощью JavaScript движка, компьютер может прочитать и понять javascript файл. JavaScript движок - это переводчик, который переводит то, что мы написали в javascript файле на язык, понятный компьютеру. Получается, движок берет наш js файл, читает его, и потом переводит его в единицы и нули, и отдает компьютеру. Компьютер теперь сможет понять, что написано в js файле.

JavaScript движок понимает язык JS.

Существует несколько JavaScript движков, Google в своем браузере Google Chrome использует V8 engine. Так же V8 engine использует Node.js

Сам V8 движок написан на C++

<hr />
Попробуйте ответить, что такое JavaScript Engine и для чего он нужен?

<details>
<summary>Ответ:</summary>

JavaScript Engine - это такая программа, переводчик, который переводит код, который мы написали на JavaScript, в язык нулей и единиц, понятный компьютеру. JavaScript движок нужен для того, чтобы компьютер сумел понять, что мы от него хотим, что мы написали в javascript файле.

</details>

<hr />

Хорошо, мы разобрались, зачем нужен JavaScript движок. А что происходит внутри этого движка, внутри этой волшебной машины, которая понимает язык JavaScript?

### Что происходит внутри JavaScript движка?

![схема того, как работает JavaScript движок](./js-engine-inside.png "Схема того, как работает JavaScript движок. Схема взята из курса Andrei Neagoie: JavaScript: The Advanced Concepts")

- мы даем движку наш javascript файл
- движок начинает выполнять парсинг этого файла, он же лексический анализ

<details>
<summary>что такое парсинг? 
</summary>

**Есливычитаетеэтоттекстскореевсеговыпойметечтотутнаписано**

Ну как, сумели прочитать эту строку? Если сумели, то вот то что сейчас сделал ваш мозг, и есть парсинг. Мозг произвел парсинг этой длинной строки, он разбил эту строку на отдельные слова, затем он присвоил значение этим словам и сформировал законченное предложение.

В случае с компьютером, парсинг работает точно также.

</details>

парсинг состоит из двух этапов:

- сначала **[сканер](https://github.com/v8/v8/blob/master/src/parsing/scanner.h)** берет javascript файл, читает его, и раскладывает код, который мы там написали, на распознанные группы. Каждая такая группа символов из javascript файла называется токеном. Токен - это идентифицированная сканером последовательность символов, подобно группировке букв в словах. Короче говоря сканер читает наш javascript файл, как человек, находит там знакомые слова, и узнает их. Когда сканер читает javascript файл, он сравнивает содержимое файла с [таблицей](https://github.com/v8/v8/blob/master/src/parsing/keywords.txt) которая имеет такой вид:

```txt file=v8/src/parsing/keywords.txt
async, Token::ASYNC
await, Token::AWAIT
break, Token::BREAK
case, Token::CASE
catch, Token::CATCH
class, Token::CLASS
const, Token::CONST
continue, Token::CONTINUE
debugger, Token::DEBUGGER
default, Token::DEFAULT
delete, Token::DELETE
do, Token::DO
else, Token::ELSE
```

сканер читает файл и видит знакомые слова, и когда сканер узнал слово, он присваивает ему токен.

- затем в дело вступает сам парсер, он берет токены, которые нашел сканер, и создает **AST (Abstract Syntax Tree, Абстрактное синтаксическое дерево)**.<br />
  AST - это такое дерево, которое внешне представляет наш код, который мы написали в файле javascript. Каждый узел этого дерева обозначает какой нибудь кусочек кода.

Сейчас будет пример того, как выглядит Абстрактное синтаксическое дерево, построенное вот из этой маленькой функции:

```js
function myLittleFunction() {
  var a = 1
  return a
}
```

![абстрактное синтаксическое дерево](ast-tree.png)

можно еще пойти на сайт [astexplorer.net](https://astexplorer.net/) и посмотреть как выглядит это дерево в виде кода, а выглядит оно так:

![абстрактное синтаксическое дерево в виде кода с сайта astexplorer.net](astexplorer-tree.png)

С помощью этого Абстрактного синтаксического дерева JavaScript движок может теперь наконец понять, что происходит в коде javascript файла. Парсер прочитал javascript файл, построил вот это AST дерево, движок посмотрел на это дерево, и ему стало понятно, что это за код мы написали.

- теперь AST дерево попадает к **Интерпретатору**. <br />
  движок V8 использует интерпретатор который называется [Ignition(зажигание)](https://github.com/v8/v8/blob/master/src/interpreter/interpreter.h).<br />
  Что делает интерпретатор? Он берет Абстрактное синтаксическое дерево, и превращает его в **байт код**

сделаем пока что паузу и поговорим про Интерпретаторы и Компиляторы

## Интерпретаторы и Компиляторы

В программировании есть два основных пути перевода исходного кода в машинный код который будет понятен компьютеру:

- при помощи интерпретатора
- при помощи компилятора

Начнем с Интерпретатора.

![схема с интерпретатором](interpreter-flow.png)

Что такое интерпретатор? Интерпретатор - это программа-переводчик, которая переводит код, который мы написали в редакторе, в другой код, который понятен компьютеру.

Вот вам такой пример:

Я говорю по-английски, а мой друг говорит по-испански. Чтобы нам поговорить друг с другом, мы нанимаем переводчика(Интерпретатора). <br />
Как работает интерпретатор?

- Я говорю одно предложение на английском.
- Интерпретатор переводит это предложение на испанский, и мой друг меня теперь понимает.
- Теперь я говорю следующее предложение, интерпретатор переводит его, и мой друг понимает что я сказал.

Вот так, предложение за предложением, происходит наше общение.

Интерпретатор читает код, который мы написали в редакторе по одной строке, строка за строкой, построчно. Перевод исходного кода в другой код, понятный компьютеру, идет на лету, строка за строкой.

Теперь поговорим про **компилятор**.

Что такое компилятор? Компилятор - это тоже программа-переводчик, как и интерпретатор, но работает она по-другому.

Вот пример:

Я говорю по-английски, а мой друг говорит по-испански. Чтобы нам поговорить друг с другом, мы теперь наняли другого переводчика(Компилятора). <br />
Как работает компилятор?

- я пишу на листе бумаги все что я хочу сказать своему другу, исписываю весь лист целиком и отдаю его компилятору
- компилятор теперь переводит все что я написал, **сразу**, а не по одной строке, и отдает моему другу. Мой друг теперь понимает, что я хочу ему сказать.

Видите разницу? Интерпретатор переводит то, что я написал своему другу по одной строке, на лету, **построчно**. А компилятор берет **весь текст**, который я написал, потом весь этот текст переводит, и только потом отдает моему другу. <br />
Как думаете, кто из них быстрее, интерпретатор или компилятор?

**Быстрее компилятор**. Знаете почему? Потому что когда работает интерпретатор, он читает код по одной строке переводит его, потом отдает его компьютеру. Потом читает новую строку, переводит ее, отдает ее компьютеру. Вот так это все продолжается раз за разом, строка за строкой.

А как работает компилятор? Он берет вообще весь код который мы написали, сразу же его весь переводит, и отдает компьютеру. Это быстрее, но проблема в том, что мы не можем теперь общаться на лету. Если я хочу сказать что то новое, мне надо сначала отредактировать текст, который я написал, и отдать его компилятору для перевода.

Подведем небольшой итог:

Интерпретатор берет JavaScript код который мы написали, и переводит его построчно в машинный код, на лету, on the fly. <br />
Компилятор берет JavaScript код который мы написали, и переводит его в машинный код за один проход, целиком.
Оба этих подхода переводят JavaScript код который мы написали, в машинный код.

JavaScript можно пропускать или через интерпретатор или через компилятор.
В чем же разница, что выбрать для чтения и перевода кода в JavaScript?

В чем плюс интерпретатора? В том что он переводит javascript код на лету. Мы загружаем javascript файл с сервера в наш браузер, и мы хотим чтобы этот javascript файл запустился сразу же, чтобы мы смогли начать взаимодействовать со страницей сайта, с самим сайтом, нажимать кнопки, совершать разные действия. Поэтому это идеальная ситуация для того, чтобы использовать интерпретатор, и изначально JavaScript как раз и использовал интерпретатор.

Но у интерпретатора есть и минусы.

Смотрите пример ниже:

```js
function someCalculation(x, y) {
  return x + y
}

for (let i = 0; i < 1000; i++) {
  someCalculation(5, 4)
}
```

Тут у нас функция someCalculation(), которая выполняет сложение x + y, ниже у нас for loop, который совершает вызов функции сложения тысячу раз. Обратите внимание, что это одна и та же операция.

И вот это как раз та ситуация, в которой интерпретатору придется тяжело. Интерпретатор немного туповат, он читает код как есть, строка за строкой, не выполняя никаких оптимизаций. Поэтому код начнет выполняться все медленнее и медленнее.

А вот компилятор здесь был бы кстати. Смотрите как этот код обработает компилятор: сначала компилятору нужно немного больше времени, чтобы перевести этот код в машинный код. Сначала происходит процесс компиляции исходного кода. Во время компиляции, компилятор пробегается по всему коду, анализирует его, видит что у нас здесь for loop, который раз за разом выполняет одну и ту же операцию, и во время перевода нашего исходного кода в машинный код, компилятор упрощает исходный код, он видит что у функции someCalculation(5, 4) в for loop одни и те же инпуты, и наша функция всегда возвращает одно и тоже, x + y. Поэтому копилятор понимает, что он может не вызывать функцию someCalculation(5, 4) раз за разом, тысячу раз, он просто меняет вызов этой функции в for loop на девятку. И прогоняет цикл 1000 раз, не вызывая функцию someCalculation(5, 4) раз за разом, вместо этого он вместо функции просто подставляет девятку!

```js highlights=6
function someCalculation(x, y) {
  return x + y
}

for (let i = 0; i < 1000; i++) {
  9
}
```

Вот потому что компилятор не будет теперь в отличие от интерпретатора выполнять функцию someCalculation(5, 4) раз за разом, тысячу раз, заменив ее на девятку, машинный код, который сгенерирует компилятор, будет исполняться быстрее! <br />
То что сейчас сделал компилятор называется оптимизацией кода.

Так вот, вернемся к вопросу о том, что же лучше, интерпретатор или компилятор?
